"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) TypeFox and others. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", { value: true });
exports.DiagnosticFeature = exports.VDiagnosticResult = void 0;
const vscode_1 = require("vscode");
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const client_1 = require("./client");
function ensure(target, key) {
    if (target[key] === void 0) {
        target[key] = {};
    }
    return target[key];
}
var VDiagnosticResult;
(function (VDiagnosticResult) {
    function hasItems(value) {
        const candidate = value;
        return candidate && Array.isArray(candidate.items);
    }
    VDiagnosticResult.hasItems = hasItems;
})(VDiagnosticResult = exports.VDiagnosticResult || (exports.VDiagnosticResult = {}));
var RequestStateKind;
(function (RequestStateKind) {
    RequestStateKind["active"] = "open";
    RequestStateKind["reschedule"] = "reschedule";
    RequestStateKind["outDated"] = "drop";
})(RequestStateKind || (RequestStateKind = {}));
class DiagnosticFeature extends client_1.TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.Proposed.DiagnosticRequest.type);
        this.openFeature = client.getFeature(vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.method);
        this.changeFeature = client.getFeature(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.method);
        this.saveFeature = client.getFeature(vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.method);
        this.closeFeature = client.getFeature(vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.method);
    }
    fillClientCapabilities(capabilities) {
        let capability = ensure(ensure(capabilities, 'textDocument'), 'diagnostic');
        capability.dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        const client = this._client;
        client.onRequest(vscode_languageserver_protocol_1.Proposed.DiagnosticRefreshRequest.type, async () => {
            for (const provider of this.getAllProviders()) {
                provider.onDidChangeDiagnosticsEmitter.fire();
            }
        });
        let [id, options] = this.getRegistration(documentSelector, capabilities.diagnosticProvider);
        if (!id || !options) {
            return;
        }
        this.register({ id: id, registerOptions: options });
    }
    registerLanguageProvider(options) {
        const documentSelector = options.documentSelector;
        const mode = vscode_languageserver_protocol_1.Proposed.DiagnosticPullModeFlags.is(options.mode) ? options.mode : (vscode_languageserver_protocol_1.Proposed.DiagnosticPullModeFlags.onOpen | vscode_languageserver_protocol_1.Proposed.DiagnosticPullModeFlags.onType);
        const disposables = [];
        const collection = vscode_1.languages.createDiagnosticCollection(options.identifier);
        disposables.push(collection);
        const availableEditors = new Set();
        const managedDocuments = new Map();
        const matches = (textDocument) => {
            return vscode_1.languages.match(documentSelector, textDocument) > 0 && availableEditors.has(textDocument.uri.toString());
        };
        const manages = (textDocument) => {
            return managedDocuments.has(textDocument.uri.toString());
        };
        const onDidChangeDiagnosticsEmitter = new vscode_1.EventEmitter();
        const provider = {
            onDidChangeDiagnostics: onDidChangeDiagnosticsEmitter.event,
            provideDiagnostics: (textDocument, context, token) => {
                const client = this._client;
                const provideDiagnostics = (textDocument, context, token) => {
                    const params = {
                        textDocument: { uri: client.code2ProtocolConverter.asUri(textDocument.uri) },
                        context: context
                    };
                    return client.sendRequest(vscode_languageserver_protocol_1.Proposed.DiagnosticRequest.type, params, token).then((result) => {
                        if (result === null || !result.items) {
                            return { items: [] };
                        }
                        return { items: client.protocol2CodeConverter.asDiagnostics(result.items) };
                    }, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.Proposed.DiagnosticRequest.type, token, error, { items: [] });
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideDiagnostics
                    ? middleware.provideDiagnostics(textDocument, context, token, provideDiagnostics)
                    : provideDiagnostics(textDocument, context, token);
            }
        };
        const requestStates = new Map();
        const pullDiagnostics = async (textDocument, trigger) => {
            var _a;
            const key = textDocument.uri.toString();
            const currentState = requestStates.get(key);
            if (currentState !== undefined) {
                if (currentState.state === RequestStateKind.active) {
                    currentState.tokenSource.cancel();
                }
                requestStates.set(key, { state: RequestStateKind.reschedule, textDocument, trigger: trigger });
                // We have a state. Wait until the request returns.
                return;
            }
            const tokenSource = new vscode_1.CancellationTokenSource();
            requestStates.set(key, { state: RequestStateKind.active, textDocument, trigger, tokenSource });
            let diagnostics;
            let afterState;
            try {
                diagnostics = (_a = await provider.provideDiagnostics(textDocument, { triggerKind: trigger }, tokenSource.token)) !== null && _a !== void 0 ? _a : { items: [] };
            }
            catch (error) {
                if (error instanceof client_1.LSPCancellationError && vscode_languageserver_protocol_1.Proposed.DiagnosticServerCancellationData.is(error.data) && error.data.retriggerRequest === false) {
                    afterState = { state: RequestStateKind.outDated, textDocument };
                }
                if (afterState === undefined && error instanceof vscode_1.CancellationError) {
                    afterState = { state: RequestStateKind.reschedule, textDocument, trigger };
                }
                else {
                    throw error;
                }
            }
            afterState = afterState !== null && afterState !== void 0 ? afterState : requestStates.get(key);
            if (afterState === undefined) {
                // This shouldn't happen. Log it
                this._client.error(`Lost request state in diagnostic pull model. Clearing diagnostics for ${key}`);
                collection.delete(textDocument.uri);
                return;
            }
            requestStates.delete(key);
            if (afterState.state === RequestStateKind.outDated || !manages(textDocument)) {
                return;
            }
            // diagnostics is only undefined if the request has thrown.
            if (diagnostics !== undefined && VDiagnosticResult.hasItems(diagnostics)) {
                collection.set(textDocument.uri, diagnostics.items);
            }
            if (afterState.state === RequestStateKind.reschedule) {
                pullDiagnostics(textDocument, afterState.trigger);
            }
        };
        const openEditorsHandler = () => {
            availableEditors.clear();
            for (const info of vscode_1.window.openEditors) {
                availableEditors.add(info.resource.toString());
            }
        };
        openEditorsHandler();
        disposables.push(vscode_1.window.onDidChangeOpenEditors(openEditorsHandler));
        if (vscode_languageserver_protocol_1.Proposed.DiagnosticPullModeFlags.isOpen(mode)) {
            disposables.push(this.openFeature.onNotificationSent((event) => {
                const textDocument = event.original;
                if (matches(textDocument)) {
                    managedDocuments.set(textDocument.uri.toString(), textDocument);
                    pullDiagnostics(event.original, vscode_languageserver_protocol_1.Proposed.DiagnosticTriggerKind.Opened);
                }
            }));
            // Pull all diagnostics for documents that are already open
            for (const textDocument of this.openFeature.openDocuments) {
                if (matches(textDocument)) {
                    managedDocuments.set(textDocument.uri.toString(), textDocument);
                    pullDiagnostics(textDocument, vscode_languageserver_protocol_1.Proposed.DiagnosticTriggerKind.Opened);
                }
            }
        }
        if (vscode_languageserver_protocol_1.Proposed.DiagnosticPullModeFlags.isType(mode)) {
            disposables.push(this.changeFeature.onNotificationSent((event) => {
                const textDocument = event.original.document;
                if (manages(textDocument) && event.original.contentChanges.length > 0) {
                    pullDiagnostics(textDocument, vscode_languageserver_protocol_1.Proposed.DiagnosticTriggerKind.Typed);
                }
            }));
        }
        if (vscode_languageserver_protocol_1.Proposed.DiagnosticPullModeFlags.isSave(mode)) {
            disposables.push(this.saveFeature.onNotificationSent((event) => {
                const textDocument = event.original;
                if (manages(textDocument)) {
                    pullDiagnostics(event.original, vscode_languageserver_protocol_1.Proposed.DiagnosticTriggerKind.Saved);
                }
            }));
        }
        disposables.push(this.closeFeature.onNotificationSent((event) => {
            const textDocument = event.original;
            const requestState = requestStates.get(textDocument.uri.toString());
            if (requestState !== undefined) {
                requestStates.set(textDocument.uri.toString(), { state: RequestStateKind.outDated, textDocument });
            }
            if (manages(textDocument)) {
                collection.delete(textDocument.uri);
                managedDocuments.delete(textDocument.uri.toString());
            }
        }));
        onDidChangeDiagnosticsEmitter.event(() => {
            for (const document of managedDocuments.values()) {
                pullDiagnostics(document, vscode_languageserver_protocol_1.Proposed.DiagnosticTriggerKind.Invoked);
            }
        });
        return [vscode_1.Disposable.from(...disposables), { onDidChangeDiagnosticsEmitter, provider }];
    }
}
exports.DiagnosticFeature = DiagnosticFeature;
//# sourceMappingURL=proposed.diagnostic.js.map